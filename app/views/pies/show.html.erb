<!-- app  .material-symbols-outlined {
  font-family: 'Material Symbols Outlined';
  font-size: 14px;
  font-variation-settings:
  'FILL' 0,
  'wght' 600,
  'GRAD' 0,
  'opsz' 20
}

body.modal-open {
  overflow: hidden;
}

/* Force navigation to display correctly on this page */
body > .main-nav {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  height: 100vh !important;
  width: 64px !important;
  min-width: 64px !important;
  background: #f7f7fa !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: stretch !important;
  gap: 8px !important;
  padding-top: 32px !important;
  z-index: 100 !important;
  transition: width 0.2s !important;
  box-sizing: border-box !important;
}es/show.html.erb -->
<style>

:root {
  --lightgray: #b1b1b1ff;
  --lightergray: #e9ecef;
}


  .pie-container {
    display: flex;
    gap: 60px;
    /* align-items: flex-start; */
    justify-content: center;
    margin: 40px 40px;
  }
  

.pie-title-editable {
  outline: none;
  border: 1px solid transparent;
  padding: 5px 15px;
  border-radius: var(--text-input-border-radius);
  cursor: text;
  transition: border-color 0.2s ease;
  
  /* Center the element and make it auto-width */
  display: inline-block;
  margin: 0 auto;
  text-align: center;
  width: auto;
}

/* Wrap the h1 in a container to center it */
.pie-title-container {
  text-align: center;
  margin-bottom: 20px;
}

.pie-title-editable:hover:not(.editing) {
  border-color: var(--focus);
}

.pie-title-editable.editing {
  border-color: var(--focus);
}



  .pie-legend-left,
  .pie-legend-right {
    /* flex: 1; */
    min-width: 150px;
    max-width: 300px;
    /* min-width: 150px; */
  }
  
  .slice-container {
    margin-bottom: 25px;
    border-radius: 0px;
    overflow: hidden;
  }
  
  .slice-link {
    font-size: 18px;
    text-decoration: none;
    color: inherit;
    display: block;
    width: 100%;
  }
  
  .slice-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-bottom: 5px;
    margin-bottom: 0px;
    border: 1px solid transparent;
  }

  

  .slice-header-container {
    padding: 0 10px;
    margin-bottom: 0px;
    border: 1px solid transparent;
    border-radius: var(--text-input-border-radius);
    transition: all 0.2s ease;
  }

  /* Remove CSS hover - let JavaScript handle all hover effects */

  .slice-header-left {
    display: flex;
    align-items: center;
  }
  
  .slice-percentage {
    font-size: 13px;
    font-weight: normal;
    color: var(--lightgray);
  }
  



/* wraps the whole elements list */
  .elements-container {
    padding-left: 7px;
    /* background: lightgray; */
    margin-bottom: 15px;
  }
  

  /* Style for individual elements */
  .element-row {
  /* background: lightblue; */
  display: flex; 
  align-items: center; 
  padding: 3px 0;
}

.element-list-view {
  padding-left: 0px;
}



/* Style for completed elements */
.element-completed-list-view {
  font-weight: normal;
  color: var(--lightgray); 
}

/* left margin when no check mark */
.check-mark-space {
  margin-right: 0px;
}


.elements-list {
  font-size: 14px;
  padding: 0;
  margin: 0;
}


  .no-elements {
    color: var(--lightgray);
    font-style: italic;
    text-align: center;
    padding: 20px;
  }
  


  #pie-section {
    /* flex-shrink: 0; */
    flex: 1;
    min-width:200px;
  }
  
  .pie-chart-container {
    text-align: center;
  }


  .progress-bar-container {
    background: var(--lightergray); /* #e9ecef; */
    margin-top: 0px;
    margin-bottom: 5px;
    height: 10px;
    border-radius: 5px;
    overflow: hidden;
  }

  .progress-bar {
    height: 100%;
    transition: width 0.3s ease;
  }



/* ============ Modal styles ============== */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  border-radius: 12px;
  padding: 0;
  max-width: 400px;
  width: 90%;
  max-height: 80vh;
  overflow: hidden;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid #e9ecef;
  text-align: center;
}

.modal-header h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
}

.modal-body {
  padding: 20px 24px;
  max-height: 60vh;
  overflow-y: auto;
}

.colors-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.color-item {
  display: flex;
  align-items: center;
  gap: 12px;
  position: relative;
}

.color-picker {
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  position: absolute;
  opacity: 0;
  z-index: 2;
}
.color-square {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 1px solid #ddd;
  flex-shrink: 0;
  cursor: pointer;
  position: relative;
  z-index: 1;
  transition: transform 0.1s ease;
}

.color-square:hover {
  transform: scale(1.1);
}

.color-label {
  font-size: 16px;
  font-weight: 500;
  flex: 1;
}

/* Style the color input when supported */
.color-picker::-webkit-color-swatch-wrapper {
  padding: 0;
  border-radius: 4px;
}

.color-picker::-webkit-color-swatch {
  border: none;
  border-radius: 4px;
}

.modal-footer {
  padding: 20px 24px;
  border-top: 1px solid #e9ecef;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.cancel-btn {
  background: #f8f9fa;
  color: #6c757d;
  border: 1px solid #dee2e6;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.save-btn {
  background: #28a745;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}


.colors-link {
  display: flex;
  align-items: center;
  gap: 8px;
  text-decoration: none;
  color: #6c757d;
  padding: 8px 12px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.colors-link:hover {
  background-color: #f8f9fa;
}

.bottom-actions {
  margin-top: 40px;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  gap: 32px;
  padding: 20px 40px;
}





.material-symbols-outlined.inline-small {
  font-size: 18px;
  vertical-align: middle;
}


.material-symbols-outlined.palette {
  font-size: 24px;
  vertical-align: middle;
}
</style>

<div class="pie-title-container">
  <h1 contenteditable="true" 
      data-field="name" 
      data-original="<%= @pie.name %>"
      data-type="pie"
      class="pie-title-editable">
    <%= @pie.name %>
  </h1>
</div>








<!-- Three-column flex container -->
<div class="pie-container">
  
  <!-- Left Legend Section -->
  <div class="pie-legend-left">
    <div>
      <% @pie.slices.each_with_index do |slice, index| %>
        <% if index < (@pie.slices.count / 2.0).ceil %>
          <div class="slice-container" data-slice-id="<%= slice.id %>">


            <!-- Slice Header -->
            <%= link_to [@pie, slice], class: "slice-link" do %>
            <div class="slice-header-container">
              <div class="slice-header">
                <div class="slice-header-left">
                  <div>
                    <strong><%= truncate(slice.name, length: 35) %></strong>
                    <div id="slice-<%= slice.id %>-stats"></div>
                  </div>
                </div>
                <div id="slice-<%= slice.id %>-percentage">
                  <div class="slice-percentage percentage">
                    <%= slice.percentage %>%
                  </div>
                </div>
              </div>

              <div class="progress-bar-container">
                  <div class="progress-bar" style="background: <%= slice.color %>; width: <%= slice.percentage %>%;"></div>
              </div>

            </div><!-- end slice-header-container -->
            <% end %>
            
            <!-- Elements List -->
            <div class="elements-container">
              <div id="slice-<%= slice.id %>-elements-list" class="elements-list">
                <% if slice.elements.any? %>
                  <% slice.elements.order(:name).each do |element| %>
                    <%= render 'pies/element_row', pie: @pie, slice: slice, element: element %>
                  <% end %>
                <% else %>
                  <div id="slice-<%= slice.id %>-no-elements" class="no-elements">
                    No elements yet.
                  </div>
                <% end %>
              </div>
            </div>
          </div>
        <% end %>
      <% end %>
    </div>
  </div>

  <!-- Pie Chart Section (Center) -->
  <div id="pie-section">
    <div id="pie-chart">
      <div class="pie-chart-container">
        <%= radial_pie_chart(@pie, size: 750, pinwheel: false, curved_labels: false) %>
      </div>
    </div>
  </div>

  <!-- Right Legend Section -->
  <div class="pie-legend-right">
    <div>
      <% @pie.slices.each_with_index do |slice, index| %>
        <% if index >= (@pie.slices.count / 2.0).ceil %>
          <div class="slice-container" data-slice-id="<%= slice.id %>">
          
          

            <!-- Slice Header -->
            <%= link_to [@pie, slice], class: "slice-link" do %>
            <div class="slice-header-container">
              <div class="slice-header">
                <div class="slice-header-left">
                  <div>
                    <strong><%= truncate(slice.name, length: 35) %></strong>
                    <div id="slice-<%= slice.id %>-stats"></div>
                  </div>
                </div>
                <div id="slice-<%= slice.id %>-percentage">
                  <div class="slice-percentage percentage">
                    <%= slice.percentage %>%
                  </div>
                </div>
              </div>

              <div class="progress-bar-container">
                  <div class="progress-bar" style="background: <%= slice.color %>; width: <%= slice.percentage %>%;"></div>
              </div>

            </div><!-- end slice-header-container -->
            <% end %>



                    <!-- Elements List -->
                    <div class="elements-container">
                      <div id="slice-<%= slice.id %>-elements-list" class="elements-list">
                        <% if slice.elements.any? %>
                          <% slice.elements.order(:name).each do |element| %>
                            <%= render 'pies/element_row', pie: @pie, slice: slice, element: element %>
                          <% end %>
                        <% else %>
                          <div id="slice-<%= slice.id %>-no-elements" class="no-elements">
                            No elements yet.
                          </div>
                        <% end %>
                      </div>
                    </div>
          </div>
        <% end %>
      <% end %>
    </div>
  </div>

</div>










<!-- Bottom Actions -->
<div class="bottom-actions">
<%= link_to "‚Üê Back to my Wheels", root_path, class: "back-to-wheel-link  " %>  



<!-- Color Palette Modal -->
  
  <%= link_to "#", class: "colors-link", onclick: "openColorsModal(); return false;" do %>
    <span class="material-symbols-outlined palette">settings</span>
  <% end %>





<%= link_to "Delete Slice", [@pie, @slice], 
      method: :delete, 
      data: { 
        confirm: "Are you sure you want to delete this slice? This will also delete all elements within it.",
        turbo_method: :delete
      },
      class: "delete-slice-link" %>
</div>










<!-- Colors Modal -->
<!-- Colors Modal -->
<div id="colors-modal" class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <div class="modal-header">
      <h2><%= @pie.name %></h2>
    </div>
    
    <div class="modal-body">
      <div class="colors-list">
        <% @pie.slices.each do |slice| %>
          <div class="color-item" data-slice-id="<%= slice.id %>">
            <input type="color" 
                   class="color-picker" 
                   value="<%= slice.color %>" 
                   data-original-color="<%= slice.color %>"
                   onchange="updateColorPreview(this)">
            <div class="color-square" style="background-color: <%= slice.color %>;"></div>
            <span class="color-label"><%= slice.name %></span>
          </div>
        <% end %>
      </div>
    </div>
    
    <div class="modal-footer">
      <button type="button" class="cancel-btn" onclick="cancelColorChanges()">Cancel</button>
      <button type="button" class="save-btn" onclick="saveColors()">Save</button>
    </div>
  </div>
</div>












<script>
// Function to initialize slice hover and click functionality
function initializeSliceInteractions() {
  console.log('Initializing slice interactions...');
  
  // Target the slice-link elements (which wrap the slice-header-container)
  const sliceLinks = document.querySelectorAll('.slice-link');
  
  console.log('Found slice links:', sliceLinks.length);
  
  sliceLinks.forEach(function(sliceLink) {
    // Check if already initialized
    if (sliceLink.hasAttribute('data-slice-listeners-attached')) {
      console.log('Slice link already has listeners attached, skipping');
      return;
    }
    
    // Mark as initialized
    sliceLink.setAttribute('data-slice-listeners-attached', 'true');
    
    // Find the slice-header-container inside this link
    const headerContainer = sliceLink.querySelector('.slice-header-container');
    
    if (headerContainer) {
      // Add hover effects using direct style properties
      sliceLink.addEventListener('mouseenter', function() {
        console.log('Mouseenter event triggered on slice link');
        headerContainer.style.border = '1px solid var(--focus)';
        headerContainer.style.backgroundColor = 'rgba(0, 124, 186, 0.05)';
        headerContainer.style.cursor = 'pointer';
      });
      
      sliceLink.addEventListener('mouseleave', function() {
        console.log('Mouseleave event triggered on slice link');
        headerContainer.style.border = '1px solid transparent';
        headerContainer.style.backgroundColor = '';
        headerContainer.style.cursor = '';
      });
      
      sliceLink.addEventListener('click', function(e) {
        console.log('Click event triggered on slice link');
        // Let the default link behavior handle navigation
      });
      
      console.log('Added hover effects to slice link');
    } else {
      console.log('No header container found inside slice link');
    }
  });
  
  console.log('Slice interactions initialized for', sliceLinks.length, 'slice links');
}

// Function to initialize pie name editing functionality
function initializePieNameEditing() {
  // Handle contenteditable pie name - be more specific and flexible
  const pieNameElement = document.querySelector('[data-type="pie"]:not([data-listeners-attached])');
  
  // Try alternative selectors if the first one fails
  let targetElement = pieNameElement;
  if (!targetElement) {
    targetElement = document.querySelector('[data-field="name"][data-type="pie"]');
  }
  if (!targetElement) {
    targetElement = document.querySelector('.pie-title-editable');
  }
  
  if (targetElement && !targetElement.hasAttribute('data-listeners-attached')) {
    targetElement.setAttribute('data-listeners-attached', 'true');
    let originalValue = targetElement.dataset.original || targetElement.innerText.trim();
    
    // Handle focus
    function handleFocus() {
      this.classList.add('editing');
    }
    
    // Handle blur - save changes
    function handleBlur() {
      this.classList.remove('editing');
      let newValue = this.innerText.trim();
      
      if (newValue !== originalValue && newValue !== '') {
        savePieField(this, newValue);
      } else if (newValue === '') {
        // Don't allow empty pie name
        this.innerText = originalValue;
        alert('Pie name cannot be empty');
      }
    }
    
    // Handle Enter key
    function handleKeydown(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.blur();
      }
      
      if (e.key === 'Escape') {
        this.innerText = originalValue;
        this.blur();
      }
    }
    
    // Add event listeners
    targetElement.addEventListener('focus', handleFocus);
    targetElement.addEventListener('blur', handleBlur);
    targetElement.addEventListener('keydown', handleKeydown);
  }
}

function savePieField(element, newValue) {
  const fieldName = element.dataset.field || 'name';
  
  // Get pie ID from URL or data attribute
  let pieId = element.dataset.pieId;
  if (!pieId) {
    const urlParts = window.location.pathname.split('/');
    const pieIndex = urlParts.indexOf('pies');
    if (pieIndex !== -1 && urlParts[pieIndex + 1]) {
      pieId = urlParts[pieIndex + 1];
    }
  }
  
  if (!pieId) {
    alert('Could not save - missing pie ID');
    return;
  }
  
  const url = '/pies/' + pieId;
  const formData = new FormData();
  
  formData.append('_method', 'PATCH');
  formData.append('pie[' + fieldName + ']', newValue);
  
  // Add CSRF token
  const csrfToken = document.querySelector('meta[name="csrf-token"]');
  if (csrfToken) {
    formData.append('authenticity_token', csrfToken.getAttribute('content'));
  }
  
  // Show saving indicator
  element.style.opacity = '0.6';
  
  fetch(url, {
    method: 'POST',
    body: formData,
    headers: {
      'X-Requested-With': 'XMLHttpRequest'
    }
  })
  .then(function(response) {
    if (response.ok) {
      // Update the original value for future comparisons
      element.dataset.original = newValue;
      
      // Update the page title if it matches the pie name
      if (document.title.includes('Pie') || document.title.includes('Balanced')) {
        document.title = newValue + ' - Radial Pie App';
      }
      
      return response.text();
    }
    throw new Error('Network response was not ok: ' + response.status);
  })
  .catch(function(error) {
    alert('Failed to save pie name. Please try again.');
    // Restore original value on error
    element.innerText = element.dataset.original || originalValue;
  })
  .finally(function() {
    element.style.opacity = '1';
  });
}

// Function to initialize pie chart slice interactivity
function initializePieChart() {
  console.log('Initializing pie chart interactions...');
  
  const pieChart = document.getElementById('pie-chart');
  if (!pieChart) {
    console.log('No pie chart element found');
    return;
  }
  
  console.log('Pie chart element found, looking for SVG elements...');
  
  // Find all SVG elements in the pie chart
  const svgElements = pieChart.querySelectorAll('svg');
  console.log('Found SVG elements:', svgElements.length);
  
  if (svgElements.length === 0) {
    console.log('No SVG elements found, trying again in 500ms...');
    setTimeout(initializePieChart, 500);
    return;
  }
  
  svgElements.forEach(function(svg, svgIndex) {
    console.log('Processing SVG element', svgIndex);
    
    // Find all path elements (pie slices) specifically
    const pathElements = svg.querySelectorAll('path');
    console.log('Found path elements (pie slices):', pathElements.length);
    
    pathElements.forEach(function(path, pathIndex) {
      // Check if path already has event listeners
      if (path.hasAttribute('data-pie-listeners-attached')) {
        console.log('Path', pathIndex, 'already has listeners, skipping');
        return;
      }
      
      // Mark as having listeners attached
      path.setAttribute('data-pie-listeners-attached', 'true');
      
      console.log('Adding listeners to path element', pathIndex);
      
      // Add hover effects with immediate test
      path.addEventListener('mouseenter', function(e) {
        console.log('üü¢ PATH HOVER DETECTED on path', pathIndex);
        this.style.cursor = 'pointer';
        this.setAttribute('fill-opacity', '0.7');
        this.setAttribute('stroke', 'var(--focus)');
        this.setAttribute('stroke-width', '1');
      });
      
      path.addEventListener('mouseleave', function(e) {
        console.log('üî¥ PATH HOVER LEAVE on path', pathIndex);
        this.setAttribute('fill-opacity', '1');
        this.removeAttribute('stroke');
        this.removeAttribute('stroke-width');
      });
      
      // Add click functionality
      path.addEventListener('click', function(e) {
        console.log('üéØ PATH CLICKED:', pathIndex);
        e.preventDefault();
        e.stopPropagation();
        
        // Get all slice containers and their details for debugging
        const sliceContainers = document.querySelectorAll('.slice-container');
        console.log('üìä Available slice containers:', sliceContainers.length);
        
        // Debug: show all slice containers and their slice names
        sliceContainers.forEach((container, index) => {
          const sliceLink = container.querySelector('.slice-link');
          const sliceName = sliceLink ? sliceLink.textContent.trim().split('\n')[0] : 'No link found';
          console.log(`  Container ${index}: "${sliceName}" -> ${sliceLink ? sliceLink.href : 'no href'}`);
        });
        
        // Debug: show all SVG paths and see if we can get any identifying info
        const allPaths = Array.from(document.querySelectorAll('#pie-chart svg path'));
        console.log('ü•ß All SVG paths:', allPaths.length);
        allPaths.forEach((p, index) => {
          const pathData = p.getAttribute('d');
          console.log(`  Path ${index}: d="${pathData ? pathData.substring(0, 50) + '...' : 'no d attribute'}"`);
        });
        
        // Try multiple strategies to find the correct slice
        let targetLink = null;
        
        // Strategy 1: Direct index matching
        console.log('üéØ Trying direct index mapping - clicked path:', pathIndex, 'total containers:', sliceContainers.length);
        if (sliceContainers[pathIndex]) {
          const sliceLink = sliceContainers[pathIndex].querySelector('.slice-link');
          if (sliceLink) {
            console.log('‚úÖ Found slice link by direct index:', sliceLink.href);
            targetLink = sliceLink;
          }
        }
        
        // Strategy 2: Try reverse index (sometimes SVG is in reverse order)
        if (!targetLink) {
          const reverseIndex = sliceContainers.length - 1 - pathIndex;
          console.log('üîÑ Trying reverse index mapping:', reverseIndex);
          if (sliceContainers[reverseIndex]) {
            const sliceLink = sliceContainers[reverseIndex].querySelector('.slice-link');
            if (sliceLink) {
              console.log('‚úÖ Found slice link by reverse index:', sliceLink.href);
              targetLink = sliceLink;
            }
          }
        }
        
        // Strategy 3: For now, let's cycle through all slices based on path index
        if (!targetLink && sliceContainers.length > 0) {
          const adjustedIndex = pathIndex % sliceContainers.length;
          console.log('üîÑ Using modulo adjustment:', adjustedIndex);
          const sliceLink = sliceContainers[adjustedIndex].querySelector('.slice-link');
          if (sliceLink) {
            console.log('‚úÖ Found slice link by adjusted index:', sliceLink.href);
            targetLink = sliceLink;
          }
        }
        
        if (targetLink) {
          console.log('üöÄ Navigating to:', targetLink.href);
          window.location.href = targetLink.href;
        } else {
          console.log('‚ùå Could not find any slice links to navigate to');
        }
      });
      
      // Test if the element is actually interactive by adding a temporary visual change
      path.style.transition = 'all 0.2s ease';
      
      console.log('‚úÖ Successfully added listeners to path', pathIndex);
    });
    
    console.log('Finished processing SVG', svgIndex, '- added listeners to', pathElements.length, 'paths');
  });
  
  console.log('üéâ Pie chart initialization complete');
}

// Initialize immediately if DOM is already ready
if (document.readyState === 'loading') {
  console.log('Document still loading, waiting for DOMContentLoaded');
} else {
  console.log('Document ready, initializing immediately');
  initializePieNameEditing();
  initializePieChart();
  initializeSliceInteractions();
}

// Initialize on DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOMContentLoaded event fired');
  initializePieNameEditing();
  initializePieChart();
  initializeSliceInteractions();
});

// Initialize on Turbo events
document.addEventListener('turbo:load', function() {
  console.log('turbo:load event fired');
  initializePieNameEditing();
  initializePieChart();
  initializeSliceInteractions();
});

document.addEventListener('turbo:render', function() {
  console.log('turbo:render event fired');
  initializePieNameEditing();
  initializePieChart();
  initializeSliceInteractions();
});

// Also try turbo:frame-load in case it's in a frame
document.addEventListener('turbo:frame-load', function() {
  console.log('turbo:frame-load event fired');
  initializePieNameEditing();
  initializePieChart();
  initializeSliceInteractions();
});

// ============ Modal functionality ============
function openColorsModal() {
  const modal = document.getElementById('colors-modal');
  if (modal) {
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
}

function closeColorsModal() {
  const modal = document.getElementById('colors-modal');
  if (modal) {
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
  }
}

function updateColorPreview(colorInput) {
  // Update the visual color square when color picker changes
  const colorSquare = colorInput.nextElementSibling;
  if (colorSquare) {
    colorSquare.style.backgroundColor = colorInput.value;
  }
}

function cancelColorChanges() {
  // Reset all colors to their original values
  document.querySelectorAll('.color-picker').forEach(function(input) {
    const originalColor = input.dataset.originalColor;
    input.value = originalColor;
    const colorSquare = input.nextElementSibling;
    if (colorSquare) {
      colorSquare.style.backgroundColor = originalColor;
    }
  });
  closeColorsModal();
}

function saveColors() {
  const colorChanges = [];
  
  // Collect all color changes
  document.querySelectorAll('.color-picker').forEach(function(input) {
    const colorItem = input.closest('.color-item');
    if (colorItem) {
      const sliceId = colorItem.dataset.sliceId;
      const newColor = input.value;
      const originalColor = input.dataset.originalColor;
      
      if (newColor !== originalColor) {
        colorChanges.push({
          sliceId: sliceId,
          color: newColor
        });
      }
    }
  });
  
  if (colorChanges.length === 0) {
    closeColorsModal();
    return;
  }
  
  // Get pie ID for color saving
  let pieId;
  const urlParts = window.location.pathname.split('/');
  const pieIndex = urlParts.indexOf('pies');
  if (pieIndex !== -1 && urlParts[pieIndex + 1]) {
    pieId = urlParts[pieIndex + 1];
  }
  
  if (!pieId) {
    alert('Could not save colors - missing pie ID');
    return;
  }
  
  // Save colors via AJAX
  Promise.all(colorChanges.map(function(change) {
    const formData = new FormData();
    formData.append('_method', 'PATCH');
    formData.append('slice[color]', change.color);
    
    // Add CSRF token
    const csrfToken = document.querySelector('meta[name="csrf-token"]');
    if (csrfToken) {
      formData.append('authenticity_token', csrfToken.getAttribute('content'));
    }
    
    return fetch('/pies/' + pieId + '/slices/' + change.sliceId, {
      method: 'POST',
      body: formData,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      }
    });
  }))
  .then(function() {
    // Update original colors for future comparisons
    document.querySelectorAll('.color-picker').forEach(function(input) {
      input.dataset.originalColor = input.value;
    });
    
    // Refresh the page to show updated colors in the pie chart
    window.location.reload();
  })
  .catch(function(error) {
    alert('Failed to save colors. Please try again.');
  });
}

// Close modal when clicking outside
document.addEventListener('click', function(e) {
  if (e.target.id === 'colors-modal') {
    closeColorsModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const modal = document.getElementById('colors-modal');
    if (modal && modal.style.display === 'flex') {
      cancelColorChanges();
    }
  }
});
</script>